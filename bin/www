#!/usr/bin/env node

/**
 * Module dependencies.
 */

var app = require('../app');
var debug = require('debug')('pugpractice:server');
var http = require('http');
var pieces = require('../public/javascripts/pieces.js')
var _ = require('lodash');

/**
 * Get port from environment and store in Express.
 */

var port = normalizePort(process.env.PORT || '8080');
app.set('port', port);

/**
 * Create HTTP server.
 */

var server = http.createServer(app);
var io = require('socket.io')(server);
  
//globals
var userNickNames = {};
var typingUsers = [];
var lobbyGameList = {}
var gameList = {}


const boardLength = 15;
const boardWidth = 9;
const startOfRedTiles = 0
const endOfRedTiles = 3
const startOfBlueTiles = 12
const endOfBlueTiles = 15

io.on('connection', function(socket)
{
  io.emit('chat message', "A new user connected");
  io.emit('online users update', userNickNames)

  for (host in lobbyGameList)
  {
    if (lobbyGameList.hasOwnProperty(host))
    {
      game = lobbyGameList[host]
      io.to(socket.id).emit('game made', game)
    }
  }

  socket.on('request to end action phase', function()
  {
    var game = findGameFromSocketID(socket.id)
    if (game == null)
    {
      io.to(socket.id).emit("new log message", "No such game")
      return
    }

    if (game.phase != "Action")
    {
      io.to(socket.id).emit("new log message", "Wrong phase")
      return      
    }

    var isRedPlayer = findIfPlayerIsRedPlayerInGameFromSocketID(game, socket.id)
    var player = (isRedPlayer) ? game.redPlayer : game.bluePlayer

    if (!findIfItsAPlayersTurnInGame(isRedPlayer, game))
    {
      io.to(socket.id).emit("new log message", "Not your turn")
      return  
    }

    game.phase = "Energize"

    io.to(game.host).emit('new game state', convertServerGameToClientGame(game)) 
  })

  socket.on('new socket connected to game', function(name)
  {
    for (host in gameList)
    {
      if (gameList.hasOwnProperty(host) && (gameList[host].redPlayer.Name == name))
      {
        gameList[host].redPlayer.socketID = socket.id
        socket.join(host)
        io.to(socket.id).emit('new game data', convertServerGameToClientGame(gameList[host]))
      }
      else if (gameList.hasOwnProperty(host) && (gameList[host].bluePlayer.Name == name))
      {
        gameList[host].bluePlayer.socketID = socket.id
        socket.join(host)
        io.to(socket.id).emit('new game data', convertServerGameToClientGame(gameList[host]))
      }
    }
  })

  socket.on('request to cast a spell', function(inventoryPosition, targetTile, targetID)
  {
    var game = findGameFromSocketID(socket.id)

    if (game == null)
    {
      io.to(socket.id).emit("new log message", "No such game")
      return
    }

    if (game.phase != "Action")
    {
      io.to(socket.id).emit("new log message", "Wrong phase")
      return      
    }

    var isRedPlayer = findIfPlayerIsRedPlayerInGameFromSocketID(game, socket.id)
    var player = (isRedPlayer) ? game.redPlayer : game.bluePlayer
    var spell = player.inventory[inventoryPosition]

    if (spell == null)
    {
      io.to(socket.id).emit("new log message", "No spell to cast")
      return      
    }  

    if (targetID == "Tile")
      var target = game.board[targetTile.col][targetTile.row]
    else if(targetID == "Flat Piece")
      var target = game.board[targetTile.col][targetTile.row].flatPiece
    else if(targetID == "Piece")
      var target = game.board[targetTile.col][targetTile.row].piece 

    if (!findIfItsAPlayersTurnInGame(isRedPlayer, game))
    {
      io.to(socket.id).emit("new log message", "Not your turn")
      return  
    }

    var tilesWhichCanBeCastOn = spell.getTilesWhichCanBeCastOn(game)

    if(!tilesWhichCanBeCastOn.includes(game.board[targetTile.col][targetTile.row]))
    {
      io.to(socket.id).emit("new log message", "Can't cast there")
      return        
    }

    spell.cast(game, target)
    player.inventory[inventoryPosition] = null

    if (targetID == "Tile")
      io.to(game.host).emit("new log message", player.Name + " casts " + spell.name + " on the tile: col: " + targetTile.col + " row: " + targetTile.row)
    else if(targetID == "Flat Piece")
      io.to(game.host).emit("new log message", player.Name + " casts " + spell.name + " on the flat piece at: col: " + targetTile.col + " row: " + targetTile.row)
    else
      io.to(game.host).emit("new log message", player.Name + " casts " + spell.name + " on the piece at: col: " + targetTile.col + " row: " + targetTile.row)

    io.to(game.host).emit('new game state', convertServerGameToClientGame(game))
  })

  socket.on('request to cast a unit spell', function(casterTile, targetTile, targetID)
  {
    var game = findGameFromSocketID(socket.id)

    if (game == null)
    {
      io.to(socket.id).emit("new log message", "No such game")
      return
    }

    if (game.phase != "Action")
    {
      io.to(socket.id).emit("new log message", "Wrong phase")
      return      
    }

    var isRedPlayer = findIfPlayerIsRedPlayerInGameFromSocketID(game, socket.id)
    var player = (isRedPlayer) ? game.redPlayer : game.bluePlayer

    if (targetID == "Tile")
      var target = game.board[targetTile.col][targetTile.row]
    else if(targetID == "Flat Piece")
      var target = game.board[targetTile.col][targetTile.row].flatPiece
    else if(targetID == "Piece")
      var target = game.board[targetTile.col][targetTile.row].piece

    var caster = game.board[casterTile.col][casterTile.row].piece

    if (!caster.hasUnitSpells)
    {
      io.to(socket.id).emit("new log message", "No spell to cast")
      return      
    }

    if(!caster.isActive)
    {
      io.to(socket.id).emit("new log message", "Piece is inactive")
      return       
    }

    if (!findIfItsAPlayersTurnInGame(isRedPlayer, game))
    {
      io.to(socket.id).emit("new log message", "Not your turn")
      return  
    }

    var tilesWhichCanBeCastOn = caster.getTilesThatUnitSpellCanBeCastOn(game)

    if(!tilesWhichCanBeCastOn.includes(game.board[targetTile.col][targetTile.row]))
    {
      io.to(socket.id).emit("new log message", "Can't cast there")
      return        
    }

    caster.castSpell(game, target)

    if (targetID == "Tile")
      io.to(game.host).emit("new log message", player.Name + "'s " + caster.name + " casts its unit spell on the tile: col: " + targetTile.col + " row: " + targetTile.row)
    else if(targetID == "Flat Piece")
      io.to(game.host).emit("new log message", player.Name + "'s " + caster.name + " casts its unit spell on the flat piece at: col: " + targetTile.col + " row: " + targetTile.row)
    else
      io.to(game.host).emit("new log message", player.Name + "'s " + caster.name + " casts its unit spell on the piece at: col: " + targetTile.col + " row: " + targetTile.row)

    io.to(game.host).emit('new game state', convertServerGameToClientGame(game))
  })

 socket.on('request tiles unit can cast on', function(pieceSpellCasterTile)
  {
    var game = findGameFromSocketID(socket.id)
    var pieceSpellCaster = game.board[pieceSpellCasterTile.col][pieceSpellCasterTile.row].piece

    if (game == null)
    {
      io.to(socket.id).emit("new log message", "No such game")
      return
    }

    if (game.phase != "Action")
    {
      io.to(socket.id).emit("new log message", "Wrong phase")
      return      
    }

    if(!pieceSpellCaster.isActive)
    {
      io.to(socket.id).emit("new log message", "Piece is inactive")
      return       
    }

    var isRedPlayer = findIfPlayerIsRedPlayerInGameFromSocketID(game, socket.id)
    var player = (isRedPlayer) ? game.redPlayer : game.bluePlayer

    if (!findIfItsAPlayersTurnInGame(isRedPlayer, game))
    {
      io.to(socket.id).emit("new log message", "Not your turn")
      return  
    }

    var castableTiles = pieceSpellCaster.getTilesThatUnitSpellCanBeCastOn(game)
    io.to(socket.id).emit('new active tiles', castableTiles) 
  })

  socket.on('request tiles which can be cast on', function(inventoryPosition)
  {
    var game = findGameFromSocketID(socket.id)

    if (game == null)
    {
      io.to(socket.id).emit("new log message", "No such game")
      return
    }

    if (game.phase != "Action")
    {
      io.to(socket.id).emit("new log message", "Wrong phase")
      return      
    }

    var isRedPlayer = findIfPlayerIsRedPlayerInGameFromSocketID(game, socket.id)
    var player = (isRedPlayer) ? game.redPlayer : game.bluePlayer

    if (!findIfItsAPlayersTurnInGame(isRedPlayer, game))
    {
      io.to(socket.id).emit("new log message", "Not your turn")
      return  
    }

    var spell = player.inventory[inventoryPosition]

    var castableTiles = spell.getTilesWhichCanBeCastOn(game)
    io.to(socket.id).emit('new active tiles', castableTiles) 
  })

  socket.on('request tiles which can be attacked', function(tile)
  {
    var game = findGameFromSocketID(socket.id)
    if (game == null)
    {
      io.to(socket.id).emit("new log message", "No such game")
      return
    }

    if (game.phase != "Action")
    {
      io.to(socket.id).emit("new log message", "Wrong phase")
      return      
    }

    var gameTile = game.board[tile.col][tile.row]
    var gamePiece = gameTile.piece
    var isRedPlayer = findIfPlayerIsRedPlayerInGameFromSocketID(game, socket.id)
    var player = (isRedPlayer) ? game.redPlayer : game.bluePlayer

    if (!findIfItsAPlayersTurnInGame(isRedPlayer, game))
    {
      io.to(socket.id).emit("new log message", "Not your turn")
      return  
    }

    if (!findIfAPlayerOwnsAPiece(isRedPlayer, gameTile.piece))
    {
      io.to(socket.id).emit("new log message", "You don't own that piece!")
      return        
    }

    if(!gameTile.piece.isActive)
    {
      io.to(socket.id).emit("new log message", "Piece is inactive")
      return       
    }

    var attackableTiles = gamePiece.getAttackableTiles(game)
    io.to(socket.id).emit('new active tiles', attackableTiles) 
  })


 socket.on('request to attack a piece', function(attackerTile, victimTile, isAttackingFlatPiece)
  {
    var game = findGameFromSocketID(socket.id)

    if (game == null)
    {
      io.to(socket.id).emit("new log message", "No such game")
      return
    }

    if (game.phase != "Action")
    {
      io.to(socket.id).emit("new log message", "Wrong phase")
      return      
    }

    var gameVictimTile = game.board[victimTile.col][victimTile.row]
    var gameAttackerTile = game.board[attackerTile.col][attackerTile.row]
    var victimPiece = isAttackingFlatPiece ? gameVictimTile.flatPiece : gameVictimTile.piece 
    var attackerPiece = gameAttackerTile.piece

    var isRedPlayer = findIfPlayerIsRedPlayerInGameFromSocketID(game, socket.id)
    var player = (isRedPlayer) ? game.redPlayer : game.bluePlayer

    if (!findIfItsAPlayersTurnInGame(isRedPlayer, game))
    {
      io.to(socket.id).emit("new log message", "Not your turn")
      return  
    }

    if (!findIfAPlayerOwnsAPiece(isRedPlayer, attackerPiece))
    {
      io.to(socket.id).emit("new log message", "You don't own that piece!")
      return        
    }

    var attackableTiles = attackerPiece.getAttackableTiles(game)

    if (!attackableTiles.includes(gameVictimTile))
    {
      io.to(socket.id).emit("new log message", "Attack out of range")
      return              
    }

    if(!attackerPiece.isActive)
    {
      io.to(socket.id).emit("new log message", "Piece is inactive")
      return       
    }

    io.to(game.host).emit("new log message", player.Name + "'s " + attackerPiece.name + " attacks the " + victimPiece.name + " on col: " + gameVictimTile.col + " row: " + gameVictimTile.row)

    attackerPiece.attack(game, victimPiece)

    io.to(game.host).emit('new game state', convertServerGameToClientGame(game))
  })

  socket.on('request tiles which can be built on', function(inventoryPosition)
  {
    var game = findGameFromSocketID(socket.id)

    if (game == null)
    {
      io.to(socket.id).emit("new log message", "No such game")
      return
    }

    if (game.phase != "Action")
    {
      io.to(socket.id).emit("new log message", "Wrong phase")
      return      
    }

    var isRedPlayer = findIfPlayerIsRedPlayerInGameFromSocketID(game, socket.id)
    var player = (isRedPlayer) ? game.redPlayer : game.bluePlayer

    if (!findIfItsAPlayersTurnInGame(isRedPlayer, game))
    {
      io.to(socket.id).emit("new log message", "Not your turn")
      return  
    }

    gamePiece = player.inventory[inventoryPosition]

    var buildableTiles = gamePiece.getTilesWhichCanBeBuiltOn(game)
    io.to(socket.id).emit('new active tiles', buildableTiles) 
  })

  socket.on('request to build a piece', function(inventoryPosition, tile)
  {
    var game = findGameFromSocketID(socket.id)

    if (game == null)
    {
      io.to(socket.id).emit("new log message", "No such game")
      return
    }

    if (game.phase != "Action")
    {
      io.to(socket.id).emit("new log message", "Wrong phase")
      return      
    }

    var tileToBuildOn = game.board[tile.col][tile.row]
    var isRedPlayer = findIfPlayerIsRedPlayerInGameFromSocketID(game, socket.id)
    var player = (isRedPlayer) ? game.redPlayer : game.bluePlayer
    var piece = player.inventory[inventoryPosition]

    if (piece == null)
    {
      io.to(socket.id).emit("new log message", "No piece to build")
      return      
    }  

    if (!findIfItsAPlayersTurnInGame(isRedPlayer, game))
    {
      io.to(socket.id).emit("new log message", "Not your turn")
      return  
    }

    var tilesWhichCanBeBuiltOn = piece.getTilesWhichCanBeBuiltOn(game)

    if(!tilesWhichCanBeBuiltOn.includes(tileToBuildOn))
    {
      io.to(socket.id).emit("new log message", "Can't build there")
      return        
    }

    if (piece.isFlat)
      tileToBuildOn.flatPiece = piece
    else
      tileToBuildOn.piece = piece

    piece.currentCol = tileToBuildOn.col
    piece.currentRow = tileToBuildOn.row

    piece.canReceiveFreeEnergyAtThisLocation = piece.canReceiveFreeEnergy(game)

    if ("addReactionsWhenBuilt" in piece)
      piece.addReactionsWhenBuilt(game)

    if ("performOnBuildEffects" in piece)
      piece.performOnBuildEffects(game)

    player.inventory[inventoryPosition] = undefined

    io.to(game.host).emit("new log message", player.Name + " builds a(n) " + piece.name + " on col: " + tileToBuildOn.col + " row: " + tileToBuildOn.row)
    io.to(game.host).emit('new game state', convertServerGameToClientGame(game))
  })

  socket.on('request tiles which can be moved to and the paths there', function(tile)
  {
    var game = findGameFromSocketID(socket.id)
    var gameTile = game.board[tile.col][tile.row]
    var gamePiece = gameTile.piece

    if (game == null)
    {
      io.to(socket.id).emit("new log message", "No such game")
      return
    }

    if (game.phase != "Action")
    {
      io.to(socket.id).emit("new log message", "Wrong phase")
      return      
    }

    var isRedPlayer = findIfPlayerIsRedPlayerInGameFromSocketID(game, socket.id)
    var player = (isRedPlayer) ? game.redPlayer : game.bluePlayer

    if (!findIfItsAPlayersTurnInGame(isRedPlayer, game))
    {
      io.to(socket.id).emit("new log message", "Not your turn")
      return  
    }

    if (!findIfAPlayerOwnsAPiece(isRedPlayer, gameTile.piece))
    {
      io.to(socket.id).emit("new log message", "You don't own that piece!")
      return        
    }

    if(!gameTile.piece.isActive)
    {
      io.to(socket.id).emit("new log message", "Piece is inactive")
      return       
    }

    var tilesThatCanBeMovedToAndThePathThere = gamePiece.getTilesWhichCanBeMovedToAndThePathThere(game)
    var listOfTilesAndPathsForClient = []

    for (tile of tilesThatCanBeMovedToAndThePathThere.keys())
    {
      var newTileAndPathList = []
      newTileAndPathList.push(tile)

      for (pathTile of tilesThatCanBeMovedToAndThePathThere.get(tile))
        newTileAndPathList.push(pathTile)

      listOfTilesAndPathsForClient.push(newTileAndPathList)
    }

    io.to(socket.id).emit('new tiles that can be moved to and the paths there', listOfTilesAndPathsForClient) 
  })

  socket.on('request to move a piece', function(fTile, tTile)
  {
    var game = findGameFromSocketID(socket.id)

    if (game == null)
    {
      io.to(socket.id).emit("new log message", "No such game")
      return
    }

    if (game.phase != "Action")
    {
      io.to(socket.id).emit("new log message", "Wrong phase")
      return      
    }

    var isRedPlayer = findIfPlayerIsRedPlayerInGameFromSocketID(game, socket.id)
    var player = (isRedPlayer) ? game.redPlayer : game.bluePlayer

    if (!findIfItsAPlayersTurnInGame(isRedPlayer, game))
    {
      io.to(socket.id).emit("new log message", "Not your turn")
      return  
    }

    var fromTile = game.board[fTile.col][fTile.row]
    var toTile = game.board[tTile.col][tTile.row]
    var movingPiece = fromTile.piece

    if (getDistanceBetweenTwoTiles(fromTile, toTile) > movingPiece.movement)
    {
      io.to(socket.id).emit("new log message", "Not enough movement")
      return
    }

    if (!findIfAPlayerOwnsAPiece(isRedPlayer, movingPiece))
    {
      io.to(socket.id).emit("new log message", "You don't own that piece!")
      return        
    }

    if(!movingPiece.isActive)
    {
      io.to(socket.id).emit("new log message", "Piece is inactive")
      return       
    }

    var moveableTilesAndThePathThere = movingPiece.getTilesWhichCanBeMovedToAndThePathThere(game)

    if (!moveableTilesAndThePathThere.has(toTile))
    {
      io.to(socket.id).emit("new log message", "Piece can't move there")
      return  
    }

    io.to(game.host).emit("new log message", player.Name + "'s " + movingPiece.name + " moves from col: " + fromTile.col + " row: " + fromTile.row + " to col: " + toTile.col + " row: " + toTile.row)
    movingPiece.move(game, moveableTilesAndThePathThere.get(toTile))
    io.to(game.host).emit('new game state', convertServerGameToClientGame(game))   
  })

  socket.on('request to energize', function(energizeT, isFlatPiece)
  {
    var game = findGameFromSocketID(socket.id)

    if (game == null)
    {
      io.to(socket.id).emit("new log message", "No such game")
      return
    }

    if (game.phase != "Energize")
    {
      io.to(socket.id).emit("new log message", "Wrong phase")
      return      
    }

    var isRedPlayer = findIfPlayerIsRedPlayerInGameFromSocketID(game, socket.id)
    var player = (isRedPlayer) ? game.redPlayer : game.bluePlayer
    var energizeTile = game.board[energizeT.col][energizeT.row]

    if (!findIfItsAPlayersTurnInGame(isRedPlayer, game))
    {
      io.to(socket.id).emit("new log message", "Not your turn")
      return  
    }

    if (isFlatPiece)
      var piece = energizeTile.flatPiece
    else
      var piece = energizeTile.piece

    if (!findIfAPlayerOwnsAPiece(isRedPlayer, piece))
    {
      io.to(socket.id).emit("new log message", "You don't own that piece!")
      return        
    }


    if (piece.energy >= piece.energyCapacity)
    {
      io.to(socket.id).emit("new log message", "Already at maxmimum energy")
      return       
    }

    if (player.activeEnergy >= player.energyCapacity)
    {
      io.to(socket.id).emit("new log message", "No free energy")
      return             
    }

    io.to(game.host).emit("new log message", player.Name + "'s " + piece.name + " on col: " + energizeTile.col + " row: " + energizeTile.row + " receives an energy")
    piece.increaseEnergy(game)

    io.to(game.host).emit('new game state', convertServerGameToClientGame(game))     
  })

  socket.on('request piece purchase', function(clientPiece)
  {

    var game = findGameFromSocketID(socket.id)

    if (clientPiece == null)
    {
      io.to(socket.id).emit("new log message", "No piece requested")
      return
    }

    if (game == null)
    {
      io.to(socket.id).emit("new log message", "No such game")
      return
    }

    if (game.phase != "Action")
    {
      io.to(socket.id).emit("new log message", "Wrong phase")
      return      
    }

    var piece = game.baseSet[clientPiece.name]
    if (piece == null && clientPiece.types.includes("Building"))
      var piece = game.nonBaseSetBuildings[clientPiece.name]
    else if (clientPiece.types.includes("Unit"))
      var piece = game.nonBaseSetUnits[clientPiece.name]
    else
      var piece = game.nonBaseSetSpells[clientPiece.name]

    if (piece == null)
    {
      io.to(socket.id).emit("new log message", "Piece not in game")
      return
    }

    var isRedPlayer = findIfPlayerIsRedPlayerInGameFromSocketID(game, socket.id)
    var player = (isRedPlayer) ? game.redPlayer : game.bluePlayer

    if (!findIfItsAPlayersTurnInGame(isRedPlayer, game))
    {
      io.to(socket.id).emit("new log message", "Not your turn")
      return  
    }

    if (player.gold < piece.cost)
    {
      io.to(socket.id).emit("new log message", "Not enough money")
      return
    }

    if (!player.inventory.includes(undefined))
    {
      io.to(socket.id).emit("new log message", "No room in inventory")
      return
    }

    player.gold = player.gold - piece.cost
    for (var i = 0; i < player.inventory.length; i++) 
    {
        if (player.inventory[i] == undefined)
        {
          var newPiece = _.cloneDeep(piece);
          player.inventory[i] = newPiece
          if (isRedPlayer)
            newPiece.owner = "Red"
          else
            newPiece.owner = "Blue"
          break
        }
    }

    io.to(game.host).emit("new log message", player.Name + " buys a " + piece.name)
    io.to(game.host).emit('new game state', convertServerGameToClientGame(game))
  })

  socket.on('request to end turn', function()
  {
    var game = findGameFromSocketID(socket.id)

    if (game == null)
    {
      io.to(socket.id).emit("new log message", "No such game")
      return
    }

    if (game.phase != "Energize")
    {
      io.to(socket.id).emit("new log message", "Wrong phase")
      return      
    }

    var isRedPlayer = findIfPlayerIsRedPlayerInGameFromSocketID(game, socket.id)
    var activePlayer = (isRedPlayer) ? game.redPlayer : game.bluePlayer

    //collection and end of turn activation, effects
    restoreMovementForPlayersPieces(game, isRedPlayer)
    activatePieces(game, isRedPlayer)
    activePlayer.goldProduction = countGoldProductionForPlayer(game, isRedPlayer)
    activePlayer.gold += activePlayer.goldProduction
    activePlayer.energyCapacity = countEnergyCapacityProductionForPlayer(game, isRedPlayer)
    activePlayer.victoryPointTokenProduction = countVictoryPointTokenProductionForPlayer(game, isRedPlayer)

    for (var tile of game.getAllTilesInListForm())
    {
      var piece = tile.piece
      var flatPiece = tile.flatPiece
      if (piece != null && "performEndOfTurnEffects" in piece && piece.isActive && findIfAPlayerOwnsAPiece(isRedPlayer, piece))
        piece.performEndOfTurnEffects(game)
      if (flatPiece != null && "performEndOfTurnEffects" in flatPiece && flatPiece.isActive && findIfAPlayerOwnsAPiece(isRedPlayer, flatPiece))
        flatPiece.performEndOfTurnEffects(game)
    }
  
    if (game.victoryPointTokenSupply < activePlayer.victoryPointTokenProduction)
    {
      activePlayer.victoryPoints += game.victoryPointTokenSupply
      game.victoryPointTokenSupply = 0
    }
    else
    {
      activePlayer.victoryPoints += activePlayer.victoryPointTokenProduction
      game.victoryPointTokenSupply -= activePlayer.victoryPointTokenProduction
    }

    if (game.victoryPointTokenSupply >= game.victoryPointTokenDrip)
      game.victoryPointTokenSupply -= game.victoryPointTokenDrip
    else
      game.victoryPointTokenSupply = 0

    //check for dead HQ
    if (game.board[4][1].piece == null || game.board[4][13].piece == null)
    {
      io.to(game.host).emit("new log message", "Game over, HQ destroyed")      

      if (game.board[4][1].piece == null && game.board[4][13].piece == null)
        io.to(game.host).emit("new log message", "It's a tie")
      else if (game.board[4][1].piece == null)
        io.to(game.host).emit("new log message", "Blue Player Wins")
      else
        io.to(game.host).emit("new log message", "Red Player Wins")

      //gameList[host] = null
      return
    }

    //check for end of game through VP tokens
    if (game.victoryPointTokenSupply == 0)
    {
      io.to(game.host).emit("new log message", "Game over on victory point tokens")      
      
      if (game.redPlayer.victoryPoints > game.bluePlayer.victoryPoints)
        io.to(game.host).emit("new log message", "Red Player Wins")
      else if (game.bluePlayer.victoryPoints > game.redPlayer.victoryPoints || isRedPlayer)
        io.to(game.host).emit("new log message", "Blue Player Wins")
      else
        io.to(game.host).emit("new log message", "It's a tie")

      //gameList[host] = null
      return
    }

    //switch players turn
    game.isRedPlayersTurn = !game.isRedPlayersTurn
    isRedPlayer = !isRedPlayer
    game.phase = "Action"

    for (var tile of game.getAllTilesInListForm())
    {
      var piece = tile.piece
      var flatPiece = tile.flatPiece
      if (piece != null && "performStartOfTurnEffects" in piece && piece.isActive && findIfAPlayerOwnsAPiece(isRedPlayer, piece))
        piece.performStartOfTurnEffects(game)
      if (flatPiece != null && "performStartOfTurnEffects" in flatPiece && flatPiece.isActive && findIfAPlayerOwnsAPiece(isRedPlayer, flatPiece))
        flatPiece.performStartOfTurnEffects(game)
    }

    if (game.isRedPlayersTurn)
      io.to(game.host).emit("new log message", game.redPlayer.Name + "'s turn")
    else
      io.to(game.host).emit("new log message", game.bluePlayer.Name + "'s turn")

    io.to(game.host).emit('new game state', convertServerGameToClientGame(game)) 
  })

  function restoreMovementForPlayersPieces(game, isRedPlayer)
  {
    for (tile of game.getAllTilesInListForm())
    {
      if(tile.piece != null && findIfAPlayerOwnsAPiece(isRedPlayer, tile.piece) && tile.piece.movementCapacity != 0)
        tile.piece.movement = tile.piece.movementCapacity
    }  
  }

  function activatePieces(game, isRedPlayer)
  {
    for (tile of game.getAllTilesInListForm())
    {
      if(tile.piece != null && findIfAPlayerOwnsAPiece(isRedPlayer, tile.piece) && tile.piece.energy >= tile.piece.minimumEnergyNeededForActivation)
        tile.piece.activate(game)
      if(tile.flatPiece != null && findIfAPlayerOwnsAPiece(isRedPlayer, tile.flatPiece) && tile.flatPiece.energy >= tile.flatPiece.minimumEnergyNeededForActivation)
        tile.flatPiece.activate(game)
    }
  }

  function updateCanReceiveFreeEnergies(game)
  {
    for (var tile of game.getAllTilesInListForm())
    {
      if(tile.piece != null)
        tile.piece.canReceiveFreeEnergyAtThisLocation = tile.piece.canReceiveFreeEnergy(game)          
      if(tile.flatPiece != null)
        tile.flatPiece.canReceiveFreeEnergyAtThisLocation = tile.flatPiece.canReceiveFreeEnergy(game)                    
    } 
  }

  function countGoldProductionForPlayer(game, isRedPlayer)
  {
    var totalGoldProduction = 0
    for (tile of game.getAllTilesInListForm())
    {
      if (tile.statuses.includes("Gold*1"))
        var multiplier = 1
      else if (tile.statuses.includes("Gold*2"))
        var multiplier = 2
      else if (tile.statuses.includes("Gold*3"))
        var multiplier = 3
      else
        var multiplier = 0

      if (tile.piece != null && tile.piece.name == "Headquarters")
        multiplier = 1
      if(tile.piece != null && findIfAPlayerOwnsAPiece(isRedPlayer, tile.piece) && tile.piece.goldProduction != null && tile.piece.isActive)
        totalGoldProduction += tile.piece.goldProduction * multiplier
      if(tile.flatPiece != null && findIfAPlayerOwnsAPiece(isRedPlayer, tile.flatPiece) && tile.flatPiece.goldProduction != null && tile.flatPiece.isActive)
        totalGoldProduction += tile.flatPiece.goldProduction * multiplier
    }
    return totalGoldProduction
  }

  function countVictoryPointTokenProductionForPlayer(game, isRedPlayer)
  {
    var totalVictoryPointTokenProduction = 0
    for (tile of game.getAllTilesInListForm())
    {
      if (tile.statuses.includes("Victory Point Tokens*2"))
        var multiplier = 2
      else if (tile.statuses.includes("Victory Point Tokens*3"))
        var multiplier = 3
      else
        var multiplier = 0

      if(tile.piece != null && findIfAPlayerOwnsAPiece(isRedPlayer, tile.piece) && tile.piece.victoryPointTokenProduction != null && tile.piece.isActive)
        totalVictoryPointTokenProduction += tile.piece.victoryPointTokenProduction*multiplier
      if(tile.flatPiece != null && findIfAPlayerOwnsAPiece(isRedPlayer, tile.flatPiece) && tile.flatPiece.victoryPointTokenProduction != null && tile.flatPiece.isActive)
        totalVictoryPointTokenProduction += tile.flatPiece.victoryPointTokenProduction*multiplier
    }
    return totalVictoryPointTokenProduction    
  }

  function countEnergyCapacityProductionForPlayer(game, isRedPlayer)
  {
    var totalEnergyCapacityProduction = 0
    for (tile of game.getAllTilesInListForm())
    {
      if (tile.statuses.includes("Energy*1"))
        var multiplier = 1
      else if (tile.statuses.includes("Energy*2"))
        var multiplier = 2
      else if (tile.statuses.includes("Energy*3"))
        var multiplier = 3
      else
        var multiplier = 0

      if (tile.piece != null && tile.piece.name == "Headquarters")
        multiplier = 1

      if(tile.piece != null && findIfAPlayerOwnsAPiece(isRedPlayer, tile.piece) && tile.piece.energyCapacityProduction != null && tile.piece.isActive)
        totalEnergyCapacityProduction += tile.piece.energyCapacityProduction*multiplier
      if(tile.flatPiece != null && findIfAPlayerOwnsAPiece(isRedPlayer, tile.flatPiece) && tile.flatPiece.energyCapacityProduction != null && tile.flatPiece.isActive)
        totalEnergyCapacityProduction += tile.flatPiece.energyCapacityProduction*multiplier
    }
    return totalEnergyCapacityProduction    
  }

  //////////////////////////////////////////
  //lobby functions
  socket.on('user trying to join game in lobby', function(host)
  {
    name = userNickNames[socket.id]
    if (name == undefined) 
    {
      io.to(socket.id).emit('chat message', 'Set nickname to join a game');
    }

    else if (name == host) 
    {
      io.to(socket.id).emit('chat message', 'Can\'t join your own game');
    }

    //make new game and start it
    else
    {
      var board = new Array(boardWidth);
      for (var col = 0; col < boardWidth; col++)
      {
        board[col] = new Array(boardLength);
        for (var row = 0; row < boardLength; row++) 
        {
          var tile = {piece: null, flatPiece: null, statuses: [], row: row, col: col}
          board[col][row] = tile
        }
      }

      //set central square VP multiplier
      board[4][7].statuses.push("Victory Point Tokens*3")

      board[4][13].piece = _.cloneDeep(pieces.baseSet['Headquarters'])
      board[4][13].piece.owner = "Blue"
      board[4][13].piece.isActive = true
      board[4][13].piece.currentCol = 4
      board[4][13].piece.currentRow = 13
      board[4][1].piece = _.cloneDeep(pieces.baseSet['Headquarters'])
      board[4][1].piece.owner = "Red"
      board[4][1].piece.isActive = true
      board[4][1].piece.currentCol = 4
      board[4][1].piece.currentRow = 1 

      //add builders
      var initialBuilderTiles = []
      initialBuilderTiles.push(board[2][12])
      initialBuilderTiles.push(board[6][12])
      initialBuilderTiles.push(board[2][2])
      initialBuilderTiles.push(board[6][2])

      for (tile of initialBuilderTiles)
      {
        tile.piece = _.cloneDeep(pieces.baseSet['Builder Drone'])
        tile.piece.isActive = true
        tile.piece.movement = 2
        tile.piece.energy = 1
        tile.piece.currentCol = tile.col
        tile.piece.currentRow = tile.row

        if (tile.row == 12)
          tile.piece.owner = "Blue"
        else
          tile.piece.owner = "Red"
      }  

      var nonHQBaseSet = _.cloneDeep(pieces.baseSet)
      delete nonHQBaseSet['Headquarters']
      var newGame =   
      {
        host: host,
        redPlayer: {socketID: null, turnsTaken: 0, Name: name, goldProduction: 5, gold: 10, victoryPointTokenProduction: 0, victoryPoints: 0, activeEnergy: 2, energyCapacity: 6, inventory: Array(5)},
        bluePlayer: {socketID: null, turnsTaken: 0, Name: host, goldProduction: 5, gold: 10, victoryPointTokenProduction: 0, victoryPoints: 0, activeEnergy: 2, energyCapacity: 6, inventory: Array(5)},
        board: board,
        reactions: new Map,
        baseSet: nonHQBaseSet,
        nonBaseSetBuildings: selectRandomNonBaseSet(pieces.nonBaseSetBuildings),
        nonBaseSetUnits: selectRandomNonBaseSet(pieces.nonBaseSetUnits),
        nonBaseSetSpells: selectRandomNonBaseSet(pieces.nonBaseSetSpells),
        victoryPointTokenSupply: 100,
        victoryPointTokenDrip: 1,
        phase: "Action",
        isRedPlayersTurn: true,

        getRedFriendlyTiles: function()
        {
          var redTiles = []
          for (var col = 0; col < boardWidth; col++)
            for (var row = startOfRedTiles; row < endOfRedTiles; row++) 
              redTiles.push(board[col][row])
          return redTiles
        },

        getBlueFriendlyTiles: function()
        {
          var blueTiles = []
          for (var col = 0; col < board.length; col++)
            for (var row = startOfBlueTiles; row < endOfBlueTiles; row++) 
              blueTiles.push(board[col][row])
          return blueTiles
        },

        getAllTilesInListForm: function()
        {
          var allTiles = []
          for (var col = 0; col < boardWidth; col++)
            allTiles = allTiles.concat(board[col])
          return allTiles
        }
      }

      assignBonusesOfType(newGame, "G")
      assignBonusesOfType(newGame, "V")
      assignBonusesOfType(newGame, "E")
      assignStartingBaseBonuses(newGame)
      gameList[host] = newGame
      socket.join(host)      
      io.to(host).emit('trigger redirect for new game', host)
    }
  })

  socket.on('make game in lobby', function(){
    name = userNickNames[socket.id]
    if (name == undefined)
    {
      io.to(socket.id).emit('chat message', 'Set nickname to make a game');
    }
    else if (name in lobbyGameList)
    {
      io.to(socket.id).emit('chat message', 'You already have a game');
    }
    else
    {
      var game = {host: name, redPlayer: name, bluePlayer: null}
      lobbyGameList[name] = game
      socket.join(game.host)
      io.emit("game made", game)
    }
  })

  //chat funcitons
  socket.on('chat message', function(msg){
    if (userNickNames[socket.id]) {
      io.emit('chat message', userNickNames[socket.id] + ": " + msg);
    }
    else {
      io.to(socket.id).emit('set nickname to start chatting');
    }
  })

  socket.on('private message', function(data){
    recipient = data.recip
    message = data.msg
    socketID = userNickNames.getKeyByValue(recipient)
    if(socketID){
      appendedMessage = "Private message to you from " + userNickNames[socket.id] + ": " + message
      io.to(socketID).emit('chat message', appendedMessage);
    }
    else{
      io.to(socket.id).emit('chat message', 'No such user');
    }
  })

  socket.on('disconnect', function(){
    if(userNickNames[socket.id]){
      if(typingUsers.includes(userNickNames[socket.id])){
        index = typingUsers.indexOf(name);
        typingUsers.splice(index, 1);
        io.emit('user stopped typing', typingUsers)
      }
    }
    io.emit('chat message', "A user disconnected");
    io.emit('online users update', userNickNames)
  })

  socket.on('new nickname', function(newNickName){
    userNickNames[socket.id] = newNickName;
    io.emit('online users update', userNickNames)
  })

  socket.on('user is typing', function(){
    name = userNickNames[socket.id];
    if(name){
      if(!typingUsers.includes(name)){
        typingUsers.push(name)
        io.emit('user is typing', typingUsers)
      }
    }
  })

  socket.on('user stopped typing', function(){
    name = userNickNames[socket.id];
    if(typingUsers.includes(name)){
        index = typingUsers.indexOf(name);
        typingUsers.splice(index, 1);
        io.emit('user stopped typing', typingUsers)
      }
  })
})

/**
 * Listen on provided port, on all network interfaces.
 */

server.listen(port);
server.on('error', onError);
server.on('listening', onListening);

/**
 * Normalize a port into a number, string, or false.
 */

Object.prototype.getKeyByValue = function( value ) {
    for(var prop in this){
      if(this.hasOwnProperty(prop)){
          if(this[prop] === value)
            return prop;
        }
    }
    return false
}

const getMethods = (obj) => {
  let properties = new Set()
  let currentObj = obj
  do {
    Object.getOwnPropertyNames(currentObj).map(item => properties.add(item))
  } while ((currentObj = Object.getPrototypeOf(currentObj)))
  return [...properties.keys()].filter(item => typeof obj[item] === 'function')
}

function assignStartingBaseBonuses(game)
{
  var bonusToAdd = "Gold*1"
  var numberOfBonuses = 0
  while (numberOfBonuses < 2)
  {
    var randomCol = getRandomNumberBetweenMinAndMax(0, boardWidth)
    var randomRow = getRandomNumberBetweenMinAndMax(0, 3)
    var tile = game.board[randomCol][randomRow]
    var sisterTile = game.board[boardWidth-randomCol-1][boardLength-randomRow-1]

    if (tile.statuses.length == 0 && tile.piece == null)
    {
      tile.statuses.push(bonusToAdd)
      sisterTile.statuses.push(bonusToAdd)
      numberOfBonuses ++
    }
  }

  var bonusToAdd = "Energy*1"
  var numberOfBonuses = 0
  while (numberOfBonuses < 2)
  {
    var randomCol = getRandomNumberBetweenMinAndMax(0, boardWidth)
    var randomRow = getRandomNumberBetweenMinAndMax(0, 3)
    var tile = game.board[randomCol][randomRow]
    var sisterTile = game.board[boardWidth-randomCol-1][boardLength-randomRow-1]

    if (tile.statuses.length == 0 && tile.piece == null)
    {
      tile.statuses.push(bonusToAdd)
      sisterTile.statuses.push(bonusToAdd)
      numberOfBonuses ++
    }
  }
}

function assignBonusesOfType(game, bonusType)
{
  var numberOfBonuses = 0
  while (numberOfBonuses < 2)
  {
    var randomCol = getRandomNumberBetweenMinAndMax(0, boardWidth)
    var randomRow = getRandomNumberBetweenMinAndMax(4, 8)
    var tile = game.board[randomCol][randomRow]

    if (tile.statuses.length == 0)
    {
      if (randomRow < 6)
      {
        if (bonusType == "G")
          var bonusToAdd = "Gold*2"
        else if(bonusType == "V")
          var bonusToAdd = "Victory Point Tokens*2"
        else
          var bonusToAdd = "Energy*2"
      }
      else
      {
        if (bonusType == "G")
          var bonusToAdd = "Gold*3"
        else if(bonusType == "V")
          var bonusToAdd = "Victory Point Tokens*3"
        else
          var bonusToAdd = "Energy*3"
      }

      var sisterTile = game.board[boardWidth-randomCol-1][boardLength-randomRow-1]

      tile.statuses.push(bonusToAdd)
      sisterTile.statuses.push(bonusToAdd)
      numberOfBonuses ++
    }
  }
}

function selectRandomNonBaseSet(pieces)
{
  var randomNonBaseSet = {}
  addUniqueRandomPiecesFromSourceToDestination(pieces, randomNonBaseSet, 5)
  return randomNonBaseSet
}

function addUniqueRandomPiecesFromSourceToDestination(source, destination, numberOfRandomPiecesToAdd)
{
  var keys = Object.keys(source);
  var piecesAdded = 0
  while (piecesAdded < numberOfRandomPiecesToAdd)
  {
    var randomIndex = getRandomNumberBetweenMinAndMax(0,keys.length)
    var randomKey = keys[randomIndex]
    var randomPiece = source[randomKey]
    if (!destination.hasOwnProperty(randomKey))
    {
      destination[randomKey] = randomPiece
      piecesAdded ++
    }
  }
}

//random number can equal min, must be less than max
function getRandomNumberBetweenMinAndMax(min, max) 
{
  return Math.floor(Math.random() * (max - min)) + min;
}

function convertServerBoardToClientBoard(board)
{
  var clientBoard = new Array(boardWidth)
  for (var col = 0; col < boardWidth; col++)
  {
    clientBoard[col] = new Array(boardLength);
    for (var row = 0; row < boardLength; row++) 
    {
      var gameTile = board[col][row]
      var clientTile = {piece: getPieceForClientFromGamePiece(gameTile.piece), flatPiece: getPieceForClientFromGamePiece(gameTile.flatPiece), statuses: gameTile.statuses, row: row, col: col}
      clientBoard[col][row] = clientTile
    }
  }
  return clientBoard          
}

function getPieceForClientFromGamePiece(gamePiece)
{
  if (gamePiece == null)
    return
  var clientPiece = {}
  Object.assign(clientPiece, gamePiece)
  return clientPiece
}

function convertServerGameToClientGame(game)
{
  var clientGame = {}
  clientGame.host = game.host
  clientGame.phase = game.phase
  clientGame.victoryPointTokenSupply = game.victoryPointTokenSupply
  clientGame.victoryPointTokenDrip = game.victoryPointTokenDrip
  clientGame.redPlayer = _.cloneDeep(game.redPlayer)
  clientGame.bluePlayer = _.cloneDeep(game.bluePlayer)
  clientGame.redPlayer.inventory = (game.redPlayer.inventory).map(getPieceForClientFromGamePiece)
  clientGame.bluePlayer.inventory = (game.bluePlayer.inventory).map(getPieceForClientFromGamePiece)
  clientGame.isRedPlayersTurn = game.isRedPlayersTurn
  clientGame.board = convertServerBoardToClientBoard(game.board)
  clientGame.baseSet = convertDictionaryToList(game.baseSet).map(getPieceForClientFromGamePiece)
  clientGame.nonBaseSetBuildings = convertDictionaryToList(game.nonBaseSetBuildings).map(getPieceForClientFromGamePiece)
  clientGame.nonBaseSetUnits = convertDictionaryToList(game.nonBaseSetUnits).map(getPieceForClientFromGamePiece)
  clientGame.nonBaseSetSpells = convertDictionaryToList(game.nonBaseSetSpells).map(getPieceForClientFromGamePiece)
  return clientGame
}

function findIfItsAPlayersTurnInGame(isRedPlayer, game){
  return (game.isRedPlayersTurn && isRedPlayer) || (!game.isRedPlayersTurn && !isRedPlayer)
}

function findIfAPlayerOwnsAPiece(isRedPlayer, piece){
  return (piece.owner == 'Red' && isRedPlayer) || (piece.owner == 'Blue' && !isRedPlayer)
}

function getDistanceBetweenTwoTiles(tile1, tile2)
{
  return Math.abs(tile1.col - tile2.col) + Math.abs(tile1.row-tile2.row)
}

function findGameFromSocketID(socketID)
{
  for (host in gameList)
    if (gameList.hasOwnProperty(host) && (gameList[host].redPlayer.socketID == socketID || gameList[host].bluePlayer.socketID == socketID))
      return gameList[host]
  return null
}

function findIfPlayerIsRedPlayerInGameFromSocketID(game, socketID)
{
  if (game.redPlayer.socketID == socketID)
    return true
  else
    return false
}

function normalizePort(val) {
  var port = parseInt(val, 10);

  if (isNaN(port)) {
    // named pipe
    return val;
  }

  if (port >= 0) {
    // port number
    return port;
  }

  return false;
}

/**
 * Event listener for HTTP server "error" event.
 */

function onError(error) 
{
  if (error.syscall !== 'listen') 
    throw error;

  var bind = typeof port === 'string'
    ? 'Pipe ' + port
    : 'Port ' + port;

  // handle specific listen errors with friendly messages
  switch (error.code) {
    case 'EACCES':
      console.error(bind + ' requires elevated privileges');
      process.exit(1);
      break;
    case 'EADDRINUSE':
      console.error(bind + ' is already in use');
      process.exit(1);
      break;
    default:
      throw error;
  }
}

function convertDictionaryToList(dict)
{
  var newList = []
  for (key in dict)
  {
    if (dict.hasOwnProperty(key))
        newList.push(dict[key])
  }
  return newList
}

function getKeyByValue(object, value) {
  return Object.keys(object).find(key => object[key] === value);
}

function onlyUnique(value, index, self) { 
    return self.indexOf(value) === index;
    //  return tilesWhichCanCurrentlyBeMovedTo.filter(onlyUnique
}

/**
 * Event listener for HTTP server "listening" event.
 */

function onListening() {
  var addr = server.address();
  var bind = typeof addr === 'string'
    ? 'pipe ' + addr
    : 'port ' + addr.port;
  debug('Listening on ' + bind);
}

function readCookie(name) {
    var nameEQ = encodeURIComponent(name) + "=";
    var ca = document.cookie.split(';');
    for (var i = 0; i < ca.length; i++) {
        var c = ca[i];
        while (c.charAt(0) === ' ')
            c = c.substring(1, c.length);
        if (c.indexOf(nameEQ) === 0)
            return decodeURIComponent(c.substring(nameEQ.length, c.length));
    }
    return null;
}
